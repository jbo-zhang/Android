##### JNI
*JNI是什么*  
JNI的全称就是Java Native Interface，即java本地开发接口。它是java的东西，不是特属于Android的东西。  
JNI是一种协议，听过那么多协议协议，怎么理解协议。 协议可以理解成规范和约束，就是只有你这么做了，别人才能收到和解读，只有别人这么回了，你才能理解收到和解读。比如http协议，有特定的headers，body等，符合http规范的就是http协议。  

##### NDK
*NDK是什么*  
NDK（Native Development Kit）是一个工具包，它封装了很多有用的工具，可以帮助我们快速得到JNI规范的代码，它还集成了“交叉编译库”，是Android中进行native开发必要的工具。  
与NDK相似的概念有JDK， SDK，一个是Java开发的工具包，一个是Android开发的工具包。

##### 交叉编译
*交叉编译是什么*  
在一个intel平台的设备上编译出可以运行于arm平台的代码就可以叫交叉编译。  
交叉编译的本质是cpu架构不同，不同的架构不能运行相同的一份代码。  
主要的cpu架构有arm，主要用于移动设备； x86，主要用于pc； MIPS，主要用于网关，猫，机顶盒。  

##### CMake LLDB
*CMake是什么*  
CMake就是一个“跨平台”的编译工具。它的主要用途是能通过一系列的“源码”和“相关的配置文件”来生成相应编译器平台上的项目文件。这么解释你可能感觉还是比较抽象，其实关于CMake涉及的知识还是很多的，不过我们目前几乎用不到。你可以简单粗暴的理解为它就是一个“工具”，什么工具呢？就是在我们用AS进行NDK开发的时候，帮我们把本地的C/C++代码生成相应的动态库（XXX.so文件）的一个工具。  

*LLDB是什么*  
Android Studio上面调试本地代码的工具。我们进行NDK开发，编写大量的C/C++代码肯定是避免不了的，当然也肯定少不了对C/C++代码的调试。想要在AS友好的调试C/C++代码，那么这个工具是少不了的。

##### 将没有勾选c/c++ support的项目引入CMake
*第一步*  
build.gradle中增加 externaleNativeBuild （共两处）  
```
android {
    compileSdkVersion 27
    defaultConfig {
        applicationId "com.example.wenshi.ndkstudy"
        minSdkVersion 15
        targetSdkVersion 27
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

        externalNativeBuild {
            cmake {
                cppFlags ""
            }
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }
}
```  
build.gradle同级目录增加CMakeList.txt  
```  
# For more information about using CMake with Android Studio, read the
# documentation: https://d.android.com/studio/projects/add-native-code.html

# Sets the minimum version of CMake required to build the native library.

cmake_minimum_required(VERSION 3.4.1)

# Creates and names a library, sets it as either STATIC
# or SHARED, and provides the relative paths to its source code.
# You can define multiple libraries, and CMake builds them for you.
# Gradle automatically packages shared libraries with your APK.

add_library( # Sets the name of the library.
        native-lib

        # Sets the library as a shared library.
        SHARED

        # Provides a relative path to your source file(s).
        src/main/jni/JNIHello.cpp)

# Searches for a specified prebuilt library and stores the path as a
# variable. Because CMake includes system libraries in the search path by
# default, you only need to specify the name of the public NDK library
# you want to add. CMake verifies that the library exists before
# completing its build.

find_library( # Sets the name of the path variable.
        log-lib

        # Specifies the name of the NDK library that
        # you want CMake to locate.
        log)

# Specifies libraries CMake should link to your target library. You
# can link multiple libraries, such as libraries you define in this
# build script, prebuilt third-party libraries, or system libraries.

target_link_libraries( # Specifies the target library.
        native-lib

        # Links the target library to the log library
        # included in the NDK.
        ${log-lib})
```  
当然，前提是安装了CMake和LLDB  
add_library就是配置c源文件和生成本地库的名称的地方，这样运行之后就可以跟ndkDuild一样生成so库了。  

##### Java调用C/C++
```java
package com.example.wenshi.ndkstudy;

public class JNIUtils {
    static {
        System.loadLibrary("native-lib");
    }
    public static native String sayHelloFromJNI();
}
```  
关键点在于保证libnative-lib.so中有一个Java_com_example_wenshi_ndkstudy_JNIUtils_sayHelloFromJNI方法。对sayHelloFromJNI方法的调用其实就是对Java_com_example_wenshi_ndkstudy_JNIUtils_sayHelloFromJNI的调用。  
通常我们的步骤是：  
1、用javah对这个java类生成一个包含native方法定义的.h头文件
```
javah -d ../jni com.example.wenshi.ndkstudy.JNIUtils
```  
得到
```c  
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_example_wenshi_ndkstudy_JNIUtils */

#ifndef _Included_com_example_wenshi_ndkstudy_JNIUtils
#define _Included_com_example_wenshi_ndkstudy_JNIUtils
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_example_wenshi_ndkstudy_JNIUtils
 * Method:    sayHelloFromJNI
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_wenshi_ndkstudy_JNIUtils_sayHelloFromJNI
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif

```  
c和c++的形参名可以不写的，但是实现的时候不推荐，头文件定义应该还行，因为这里的默认生成的就是不写形参名的，不过形参名可以让可读性更好。  
2、有了头文件，那么写一个c或者cpp文件实现这个头文件方法即可  
```cpp
//
// Created by wenshi on 19-5-23.
//
#include "com_example_wenshi_ndkstudy_JNIUtils.h"

/*
 * Class:     com_example_wenshi_ndkstudy_JNIUtils
 * Method:    sayHelloFromJNI
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_wenshi_ndkstudy_JNIUtils_sayHelloFromJNI
  (JNIEnv *env, jclass jclass) {
    return env->NewStringUTF("Hello World from JNI !!!");
  }

```  
使用CMake的可以直接写一个cpp文件，而少掉生成.h文件那一步。不过这个文件必须要有必要的头文件包含  
```c
#include <jni.h>
#include <string>

extern "C" JNIEXPORT jstring JNICALL
Java_com_example_wenshi_cmakestudy_MainActivity_stringFromJNI(
        JNIEnv *env,
        jobject /* this */) {
    std::string hello = "Hello from C++";
    return env->NewStringUTF(hello.c_str());
}

```

对于一个写好的c或者c++项目，如果要用java启动，那么只需要提供一个入口供java调用，然后这个入口方法中调用这个项目的入口方法就可以了，c/c++可以任意放飞自我。  

##### C/C++调用Java
C/C++对Java的调用不能平白无故产生， 必须Java先调用C/C++，然后C/C++才能调用Java。为什么Java调用C/C++可以由Java先发起，而C/C++调用Java不能由C/C++先发起呢。大概的原因是Java运行环境的问题，Java运行必须依赖于Java虚拟机，如果Java虚拟机没有启动那么Java代码也就没有办法运行了，你随便写个C/C++运行，跟Java虚拟机是没有关系的，所以必须先启动Java虚拟机。从Java代码出发，就能得到必要的运行环境，C/C++才能用这个运行环境去执行Java代码。

C或者C++对Java的调用类似于反射，都有一个大概的步骤。

1、得到Class对象。如果调用C/C++方法的对象和你要获得的Class是同一个，那么直接
```c
jclass cls = env->GetObjectClass(obj);
```  
如果不是，那么可以用FindClass，比如：
```c
jclass cls = env->FindClass("java/util/Date");
```

2、得到Class对象一般是为了得到属性或者方法,比如
```c  
 //得到属性
 jfieldID fid = env->GetFieldID(cls, "s", "Ljava/lang/String;");
 //得到静态属性
 jfieldID fid = env->GetStaticFieldID(cls, "county", "I");
 //得到方法
 jmethodID mid = env->GetMethodID(cls, "genRandomInt", "(I)I");
 //得到静态方法
 jmethodID mid = env->GetStaticMethodID(cls, "getUUID", "()Ljava/lang/String;");
 //得到构造方法
 jmethodID constuctor_methodID = env->GetMethodID(cls, "<init>", "()V");
```
3、操作属性，或调用方法，或创建对象
```c
//获取属性值
jstring jstr = (jstring) env->GetObjectField(obj, fid);
//获取静态属性值
jint count = env->GetStaticIntField(cls, fid);
//设置属性值
env->SetObjectField(obj, fid, new_jstr);
//设置静态属性值
env->SetStaticIntField(cls, fid, count);
//调用方法
env->CallIntMethod(obj, mid, 10);
//调用静态方法
jstring jstr = (jstring) env->CallStaticObjectMethod(cls, mid);
//生成对象
jobject data_obj = env->NewObject(cls, constuctor_methodID);
```  
对Java的处理几乎都是采用JNIEnv这个指针变量的方法。步骤总结就是1、得到Class对象；2、采用名字和签名从Class中得到需要的属性或方法；3、对属性或者方法进行操作。  

其中第二步很重要，它决定了能不能准确操作属性或者调用方法，其中的签名是比较冷门的概念。其实class对象的属性和方法都有签名，可以采用  
```
javap -s -p com.example.zhangxudong.ndkdemo.MainActivity
```
得到。操作时必须已经生成了MainActivity.class。javac无法直接编译操作Activity类，可以去build目录下找MainActivity.class对象。  

记住几个比较重要的类jclass, jobject, jmethodID, jfieldID, jstring, jint, jboolean,...  

char *与jstring的转化  
```c
jstring jstr = (jstring) env->GetObjectField(obj, fid);
const char *c_str = env->GetStringUTFChars(jstr,JNI_FALSE);
char text[20] = "super  ";
strcat(text,c_str);
jstring new_jstr = env->NewStringUTF(text);
env->ReleaseStringUTFChars(jstr,c_str);
```

用了JNIEnv的转化方法之后必须记得Release， 如：  
```c
extern "C"
JNIEXPORT void JNICALL
Java_com_example_wenshi_cmakestudy_MainActivity_giveArray(JNIEnv *env, jobject instance,
                                                          jintArray array_) {
    jint *array = env->GetIntArrayElements(array_, NULL);
    // TODO
    env->ReleaseIntArrayElements(array_, array, 0);
}

extern "C"
JNIEXPORT void JNICALL
Java_com_example_wenshi_cmakestudy_MainActivity_giveString(JNIEnv *env, jobject instance,
                                                           jstring string_) {
    const char *string = env->GetStringUTFChars(string_, 0);
    // TODO
    env->ReleaseStringUTFChars(string_, string);
}

```
题外话：->与.的区别  \*xy.name="hhhhh" 等价于xy->name="hhhhh"。简单总结就是->是用于指针的，而.是用于对象的。箭头相当于省略了指针提取过程。xy->相当与\*xy.  
